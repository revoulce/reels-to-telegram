const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const {Telegraf} = require('telegraf');
const {v4: uuidv4} = require('uuid');
const {exec} = require('child_process');
const {promisify} = require('util');

const execAsync = promisify(exec);

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
const config = {
    PORT: process.env.PORT || 3000,
    BOT_TOKEN: process.env.BOT_TOKEN || 'YOUR_BOT_TOKEN',
    CHANNEL_ID: process.env.CHANNEL_ID || '@your_channel',
    API_KEY: process.env.API_KEY || 'your-secret-api-key',
    TEMP_DIR: './temp',
    MAX_FILE_SIZE: 50 * 1024 * 1024, // 50MB
    DOWNLOAD_TIMEOUT: 60000, // 60 seconds
    SUPPORTED_DOMAINS: ['instagram.com', 'www.instagram.com']
};

// –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
if (!fs.existsSync(config.TEMP_DIR)) {
    fs.mkdirSync(config.TEMP_DIR, { recursive: true });
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
const app = express();
const bot = new Telegraf(config.BOT_TOKEN);

// Middleware
app.use(cors({
    origin: [
        'https://www.instagram.com',
        'chrome-extension://*'
    ],
    credentials: true
}));

app.use(express.json({ limit: '10mb' }));

// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤
app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.path} - ${req.ip}`);
    next();
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ API –∫–ª—é—á–∞
const authenticateApiKey = (req, res, next) => {
    const apiKey = req.headers['x-api-key'];
    if (!apiKey) {
        return res.status(401).json({ error: 'API key required' });
    }
    if (apiKey !== config.API_KEY) {
        return res.status(401).json({ error: 'Invalid API key' });
    }
    next();
};

// –í–∞–ª–∏–¥–∞—Ü–∏—è URL
const validateInstagramUrl = (url) => {
    try {
        const urlObj = new URL(url);
        const isInstagram = config.SUPPORTED_DOMAINS.includes(urlObj.hostname);
        const isValidPath = urlObj.pathname.includes('/reels/') ||
            urlObj.pathname.includes('/reel/') ||
            urlObj.pathname.includes('/stories/') ||
            urlObj.pathname.includes('/p/');

        return isInstagram && isValidPath;
    } catch {
        return false;
    }
};

// –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
async function extractMetadata(pageUrl) {
    try {
        console.log('üìä Extracting metadata for:', pageUrl);

        const command = `yt-dlp --dump-json --no-download --quiet "${pageUrl}"`;
        const { stdout } = await execAsync(command, {
            timeout: 30000,
            maxBuffer: 1024 * 1024 * 10 // 10MB buffer
        });

        const metadata = JSON.parse(stdout);

        const result = {
            title: cleanText(metadata.title || metadata.description || ''),
            author: cleanText(metadata.uploader || metadata.channel || ''),
            duration: metadata.duration || 0,
            view_count: metadata.view_count || 0,
            like_count: metadata.like_count || 0,
            upload_date: metadata.upload_date || null,
            thumbnail: metadata.thumbnail || null
        };

        console.log('‚úÖ Metadata extracted:', {
            author: result.author || 'Unknown',
            titleLength: result.title.length,
            duration: result.duration,
            views: result.view_count
        });

        return result;
    } catch (error) {
        console.warn('‚ö†Ô∏è Could not extract metadata:', error.message);
        return {
            title: '',
            author: '',
            duration: 0,
            view_count: 0,
            like_count: 0
        };
    }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞
function cleanText(text) {
    if (!text) return '';
    return text
        .replace(/[\u{1F600}-\u{1F64F}]/gu, '') // Remove some emojis if needed
        .replace(/\s+/g, ' ')
        .trim()
        .substring(0, 200); // Limit length
}

// –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤–∏–¥–µ–æ
async function downloadVideo(pageUrl, outputPath) {
    console.log('üì• Starting download from:', pageUrl);

    const command = `yt-dlp --cookies "cookies.txt" -f "best[ext=mp4]/best" -o "${outputPath}" "${pageUrl}" --no-playlist --max-filesize ${config.MAX_FILE_SIZE}`;

    try {
        const { stdout, stderr } = await execAsync(command, {
            timeout: config.DOWNLOAD_TIMEOUT,
            maxBuffer: 1024 * 1024 * 50 // 50MB buffer
        });

        if (stderr) {
            console.log('yt-dlp warnings:', stderr);
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —Å–æ–∑–¥–∞–Ω –∏ –Ω–µ –ø—É—Å—Ç–æ–π
        if (fs.existsSync(outputPath)) {
            const stats = fs.statSync(outputPath);
            if (stats.size > 0) {
                console.log(`‚úÖ Download successful: ${formatFileSize(stats.size)}`);
                return outputPath;
            }
        }

        throw new Error('Downloaded file is empty or missing');
    } catch (error) {
        console.error('‚ùå Download failed:', error.message);

        // Cleanup incomplete file
        if (fs.existsSync(outputPath)) {
            fs.unlinkSync(outputPath);
        }

        throw error;
    }
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–µ–ª
function formatNumber(num) {
    if (!num || num === 0) return '';

    if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
    } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
    }

    return num.toLocaleString();
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞
function formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// –°–æ–∑–¥–∞–Ω–∏–µ caption –¥–ª—è Telegram
function createCaption(metadata, pageUrl) {
    let caption = '';

    // –ó–∞–≥–æ–ª–æ–≤–æ–∫/–æ–ø–∏—Å–∞–Ω–∏–µ
    if (metadata.title) {
        caption += `üé¨ ${metadata.title}\n\n`;
    }

    // –ê–≤—Ç–æ—Ä
    if (metadata.author) {
        caption += `üë§ ${metadata.author}\n`;
    }

    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    if (metadata.view_count > 0) {
        caption += `üëÅ ${formatNumber(metadata.view_count)} –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤\n`;
    }

    if (metadata.like_count > 0) {
        caption += `‚ù§Ô∏è ${formatNumber(metadata.like_count)} –ª–∞–π–∫–æ–≤\n`;
    }

    // –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
    if (metadata.duration > 0) {
        const minutes = Math.floor(metadata.duration / 60);
        const seconds = metadata.duration % 60;
        caption += `‚è± ${minutes}:${seconds.toString().padStart(2, '0')}\n`;
    }

    // –ò—Å—Ç–æ—á–Ω–∏–∫
    caption += `\nüîó ${pageUrl}`;

    return caption.substring(0, 1024); // Telegram limit
}

// Cleanup —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤
function cleanupOldFiles() {
    const maxAge = 60 * 60 * 1000; // 1 hour
    const now = Date.now();

    try {
        const files = fs.readdirSync(config.TEMP_DIR);
        let cleaned = 0;

        files.forEach(file => {
            const filePath = path.join(config.TEMP_DIR, file);
            const stats = fs.statSync(filePath);

            if (now - stats.mtime.getTime() > maxAge) {
                fs.unlinkSync(filePath);
                cleaned++;
            }
        });

        if (cleaned > 0) {
            console.log(`üßπ Cleaned ${cleaned} old files`);
        }
    } catch (error) {
        console.error('Error cleaning old files:', error);
    }
}

// Health check endpoints
app.get('/health', (req, res) => {
    res.json({
        status: 'OK',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage()
    });
});

app.get('/api/health', (req, res) => {
    res.json({
        status: 'OK',
        version: '2.1.0',
        timestamp: new Date().toISOString()
    });
});

// –û—Å–Ω–æ–≤–Ω–æ–π endpoint –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ
app.post('/api/download-video', authenticateApiKey, async (req, res) => {
    const startTime = Date.now();
    const { videoUrl, pageUrl, timestamp } = req.body;

    console.log('\nüöÄ New video processing request:', {
        pageUrl,
        hasVideoUrl: !!videoUrl,
        timestamp
    });

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!pageUrl) {
        return res.status(400).json({ error: 'pageUrl is required' });
    }

    if (!validateInstagramUrl(pageUrl)) {
        return res.status(400).json({ error: 'Invalid Instagram URL' });
    }

    const tempFileName = `video_${uuidv4()}.mp4`;
    const tempFilePath = path.join(config.TEMP_DIR, tempFileName);

    try {
        // –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤
        cleanupOldFiles();

        // –ò–∑–≤–ª–µ–∫–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
        const metadata = await extractMetadata(pageUrl);

        // –°–∫–∞—á–∏–≤–∞–µ–º –≤–∏–¥–µ–æ
        await downloadVideo(pageUrl, tempFilePath);

        // –°–æ–∑–¥–∞–µ–º caption
        const caption = createCaption(metadata, pageUrl);

        console.log('üì§ Sending to Telegram...');
        console.log('Caption preview:', caption.substring(0, 100) + '...');

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Telegram
        const message = await bot.telegram.sendVideo(
            config.CHANNEL_ID,
            { source: tempFilePath },
            {
                caption,
                parse_mode: 'HTML',
                disable_notification: false
            }
        );

        console.log(`‚úÖ Video sent successfully in ${Date.now() - startTime}ms`);

        // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        if (fs.existsSync(tempFilePath)) {
            fs.unlinkSync(tempFilePath);
        }

        res.json({
            success: true,
            message: 'Video sent to Telegram successfully',
            processingTime: Date.now() - startTime,
            metadata: {
                author: metadata.author || 'Unknown',
                title: metadata.title || 'Instagram Video',
                views: metadata.view_count,
                likes: metadata.like_count,
                duration: metadata.duration
            },
            telegramMessageId: message.message_id
        });

    } catch (error) {
        console.error('‚ùå Error processing video:', error.message);

        // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
        if (fs.existsSync(tempFilePath)) {
            fs.unlinkSync(tempFilePath);
        }

        let errorMessage = 'Failed to process video';
        let statusCode = 500;

        if (error.message.includes('timeout')) {
            errorMessage = 'Download timeout - video might be too large';
            statusCode = 408;
        } else if (error.message.includes('Unauthorized') || error.message.includes('403')) {
            errorMessage = 'Access denied - video might be private';
            statusCode = 403;
        } else if (error.message.includes('not available')) {
            errorMessage = 'Video not available or deleted';
            statusCode = 404;
        }

        res.status(statusCode).json({
            success: false,
            error: errorMessage,
            details: process.env.NODE_ENV === 'development' ? error.message : undefined,
            processingTime: Date.now() - startTime
        });
    }
});

// Endpoint –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
app.get('/api/stats', authenticateApiKey, (req, res) => {
    const tempFiles = fs.readdirSync(config.TEMP_DIR).length;

    res.json({
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        tempFiles,
        config: {
            maxFileSize: formatFileSize(config.MAX_FILE_SIZE),
            downloadTimeout: config.DOWNLOAD_TIMEOUT / 1000 + 's'
        }
    });
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ –±–æ—Ç–∞
bot.command('start', (ctx) => {
    ctx.reply(
        'üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –≤–∏–¥–µ–æ –∏–∑ Instagram Reels.\n\n' +
        'üîß –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –±—Ä–∞—É–∑–µ—Ä–Ω–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∏ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –µ–≥–æ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤–∏–¥–µ–æ –≤ –∫–∞–Ω–∞–ª.\n\n' +
        'üìä –ö–æ–º–∞–Ω–¥—ã:\n' +
        '/info - –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ\n' +
        '/stats - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞–±–æ—Ç—ã'
    );
});

bot.command('info', (ctx) => {
    ctx.reply(
        'ü§ñ Instagram to Telegram Bot v2.1\n\n' +
        'üìù –§—É–Ω–∫—Ü–∏–∏:\n' +
        '‚Ä¢ –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∏–∑ Instagram Reels –∏ Stories\n' +
        '‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö\n' +
        '‚Ä¢ –ü—É–±–ª–∏–∫–∞—Ü–∏—è –≤ Telegram –∫–∞–Ω–∞–ª\n' +
        '‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –±—Ä–∞—É–∑–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è\n\n' +
        'üõ† –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏: Node.js + yt-dlp + Telegraf'
    );
});

bot.command('stats', async (ctx) => {
    const uptime = Math.floor(process.uptime());
    const hours = Math.floor(uptime / 3600);
    const minutes = Math.floor((uptime % 3600) / 60);

    ctx.reply(
        `üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞:\n\n` +
        `‚è± –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: ${hours}—á ${minutes}–º\n` +
        `üíæ –ü–∞–º—è—Ç—å: ${Math.round(process.memoryUsage().rss / 1024 / 1024)}MB\n` +
        `üìÅ –í—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤: ${fs.readdirSync(config.TEMP_DIR).length}\n` +
        `üîÑ –°—Ç–∞—Ç—É—Å: –ê–∫—Ç–∏–≤–µ–Ω`
    );
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
app.use((error, req, res, next) => {
    console.error('Express error:', error);
    res.status(500).json({
        error: 'Internal server error',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
});

// Graceful shutdown
const shutdown = () => {
    console.log('\nüîÑ Shutting down gracefully...');

    // Cleanup temp files
    try {
        const files = fs.readdirSync(config.TEMP_DIR);
        files.forEach(file => {
            fs.unlinkSync(path.join(config.TEMP_DIR, file));
        });
        console.log('üßπ Temporary files cleaned');
    } catch (error) {
        console.error('Error during cleanup:', error);
    }

    // Stop bot
    bot.stop('SIGTERM');
    process.exit(0);
};

process.once('SIGINT', shutdown);
process.once('SIGTERM', shutdown);

// –ó–∞–ø—É—Å–∫
const start = async () => {
    try {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
        await execAsync('yt-dlp --version');
        console.log('‚úÖ yt-dlp found');

        // –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
        app.listen(config.PORT, () => {
            console.log(`üöÄ Server running on port ${config.PORT}`);
            console.log(`üìÅ Temp directory: ${config.TEMP_DIR}`);
            console.log(`üì∫ Telegram channel: ${config.CHANNEL_ID}`);
        });

        // –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
        await bot.launch();
        console.log('ü§ñ Telegram bot started');

        // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞
        setInterval(cleanupOldFiles, 30 * 60 * 1000); // Every 30 minutes

    } catch (error) {
        console.error('‚ùå Failed to start:', error.message);

        if (error.message.includes('yt-dlp')) {
            console.log('\nüí° Install yt-dlp: pip install yt-dlp');
        }

        process.exit(1);
    }
};

start();