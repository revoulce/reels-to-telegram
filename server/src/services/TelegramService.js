const { Telegraf } = require("telegraf");
const config = require("../config");

/**
 * Telegram Service - handles all Telegram bot operations
 */
class TelegramService {
  constructor() {
    this.bot = new Telegraf(config.BOT_TOKEN);
    this.setupCommands();
  }

  /**
   * Send media to Telegram channel from memory buffer
   * @param {Buffer} mediaBuffer
   * @param {object} metadata
   * @param {string} pageUrl
   * @param {string} jobId
   * @param {string} mediaType
   * @returns {Promise<object>}
   */
  async sendMedia(mediaBuffer, metadata, pageUrl, jobId, mediaType = "video") {
    if (mediaType === "photo" || this.isImageContent(mediaBuffer)) {
      return this.sendPhoto(mediaBuffer, metadata, pageUrl, jobId);
    } else {
      return this.sendVideo(mediaBuffer, metadata, pageUrl, jobId);
    }
  }

  /**
   * Send photo to Telegram channel from memory buffer
   * @param {Buffer} photoBuffer
   * @param {object} metadata
   * @param {string} pageUrl
   * @param {string} jobId
   * @returns {Promise<object>}
   */
  async sendPhoto(photoBuffer, metadata, pageUrl, jobId) {
    const caption = this.createCaption(metadata, pageUrl);

    try {
      const message = await this.bot.telegram.sendPhoto(
        config.CHANNEL_ID,
        {
          source: photoBuffer,
          filename: `post_${jobId.substring(0, 8)}.jpg`,
        },
        {
          caption,
          parse_mode: "HTML",
        }
      );

      console.log(`üì§ Photo sent to Telegram: ${metadata.title || "Untitled"}`);
      return message;
    } catch (error) {
      throw new Error(`Failed to send photo to Telegram: ${error.message}`);
    }
  }

  /**
   * Send video to Telegram channel from memory buffer
   * @param {Buffer} videoBuffer
   * @param {object} metadata
   * @param {string} pageUrl
   * @param {string} jobId
   * @returns {Promise<object>}
   */
  async sendVideo(videoBuffer, metadata, pageUrl, jobId) {
    const caption = this.createCaption(metadata, pageUrl);

    try {
      const message = await this.bot.telegram.sendVideo(
        config.CHANNEL_ID,
        {
          source: videoBuffer,
          filename: `reel_${jobId.substring(0, 8)}.mp4`,
        },
        {
          caption,
          parse_mode: "HTML",
          disable_notification: false,
        }
      );

      console.log(`üì§ Video sent to Telegram: ${metadata.title || "Untitled"}`);
      return message;
    } catch (error) {
      console.error(`‚ùå Telegram send failed:`, error.message);
      throw new Error(`Failed to send to Telegram: ${error.message}`);
    }
  }

  /**
   * Check if buffer contains image content
   * @param {Buffer} buffer
   * @returns {boolean}
   */
  isImageContent(buffer) {
    const header = buffer.slice(0, 8);
    return (
      (buffer[0] === 0xff && buffer[1] === 0xd8) || // JPEG
      header.toString("hex").startsWith("89504e47") || // PNG
      header.toString("hex").startsWith("47494638")
    ); // GIF
  }

  /**
   * Create caption for Telegram message
   * @param {object} metadata
   * @param {string} pageUrl
   * @returns {string}
   */
  createCaption(metadata, pageUrl) {
    let caption = "";

    if (metadata.title) {
      caption += `üé¨ ${metadata.title}\n\n`;
    }

    if (metadata.author) {
      caption += `üë§ ${metadata.author}\n`;
    }

    if (metadata.view_count > 0) {
      caption += `üëÅ ${this.formatNumber(metadata.view_count)} –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤\n`;
    }

    if (metadata.like_count > 0) {
      caption += `‚ù§Ô∏è ${this.formatNumber(metadata.like_count)} –ª–∞–π–∫–æ–≤\n`;
    }

    if (metadata.duration > 0) {
      const minutes = Math.floor(metadata.duration / 60);
      const seconds = metadata.duration % 60;
      caption += `‚è± ${minutes}:${seconds.toString().padStart(2, "0")}\n`;
    }

    caption += `\nüîó ${pageUrl}`;
    caption += `\nüíæ Processed in memory (zero disk usage)`;

    return caption.substring(0, 1024);
  }

  /**
   * Format number with K/M suffixes
   * @param {number} num
   * @returns {string}
   */
  formatNumber(num) {
    if (!num || num === 0) return "";
    if (num >= 1000000) return (num / 1000000).toFixed(1) + "M";
    if (num >= 1000) return (num / 1000).toFixed(1) + "K";
    return num.toLocaleString();
  }

  /**
   * Setup bot commands
   */
  setupCommands() {
    this.bot.command("start", (ctx) => {
      ctx.reply(
        "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –≤–∏–¥–µ–æ –∏–∑ Instagram Reels.\n\n" +
          "üîß –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –±—Ä–∞—É–∑–µ—Ä–Ω–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∏ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –µ–≥–æ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤–∏–¥–µ–æ –≤ –∫–∞–Ω–∞–ª.\n\n" +
          "‚ö° Memory Edition v3.0 –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:\n" +
          "‚Ä¢ üíæ –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∏–¥–µ–æ –≤ –ø–∞–º—è—Ç–∏ (zero disk usage)\n" +
          "‚Ä¢ üöÄ –û—á–µ—Ä–µ–¥—å –¥–æ 3 –≤–∏–¥–µ–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ\n" +
          "‚Ä¢ üìä –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏\n" +
          "‚Ä¢ üßπ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏\n\n" +
          "üìä –ö–æ–º–∞–Ω–¥—ã:\n" +
          "/memory - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏\n" +
          "/queue - —Å—Ç–∞—Ç—É—Å –æ—á–µ—Ä–µ–¥–∏\n" +
          "/stats - –æ–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n" +
          "/info - –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ"
      );
    });

    // Commands will be set up by the main VideoQueue when it has access to stats
  }

  /**
   * Set up command handlers with access to queue stats
   * @param {function} getQueueStats
   * @param {function} getMemoryStats
   */
  setupStatsCommands(getQueueStats, getMemoryStats) {
    this.bot.command("memory", async (ctx) => {
      const memoryStats = getMemoryStats();
      const processMemory = process.memoryUsage();

      ctx.reply(
        `üíæ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏:\n\n` +
          `üîÑ –û—á–µ—Ä–µ–¥—å: ${memoryStats.currentFormatted} / ${memoryStats.maxFormatted} (${memoryStats.utilization}%)\n` +
          `üìà –ü–∏–∫: ${memoryStats.peakFormatted}\n` +
          `üñ• –ü—Ä–æ—Ü–µ—Å—Å: ${this.formatMemory(processMemory.rss)}\n` +
          `üìä Heap: ${this.formatMemory(
            processMemory.heapUsed
          )} / ${this.formatMemory(processMemory.heapTotal)}\n\n` +
          `üìπ –ê–∫—Ç–∏–≤–Ω—ã—Ö –≤—ã–¥–µ–ª–µ–Ω–∏–π: ${memoryStats.activeAllocations}\n` +
          `‚ö° –†–µ–∂–∏–º: Zero disk usage\n` +
          `üìà –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –≤—Å–µ–≥–æ: ${getQueueStats().totalProcessed}`
      );
    });

    this.bot.command("queue", async (ctx) => {
      const stats = getQueueStats();
      const memoryStats = getMemoryStats();

      ctx.reply(
        `üìä –°—Ç–∞—Ç—É—Å –æ—á–µ—Ä–µ–¥–∏ (Memory Mode):\n\n` +
          `‚è≥ –í –æ—á–µ—Ä–µ–¥–∏: ${stats.queued}\n` +
          `üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è: ${stats.processing}\n` +
          `‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ: ${stats.completed}\n` +
          `‚ùå –û—à–∏–±–∫–∏: ${stats.failed}\n` +
          `üë∑ –ê–∫—Ç–∏–≤–Ω—ã—Ö –≤–æ—Ä–∫–µ—Ä–æ–≤: ${stats.processing}/${config.MAX_CONCURRENT_DOWNLOADS}\n\n` +
          `üíæ –ü–∞–º—è—Ç—å: ${memoryStats.currentFormatted} / ${memoryStats.maxFormatted} (${memoryStats.utilization}%)\n` +
          `üìà –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: ${stats.throughputPerMinute} –≤–∏–¥–µ–æ/–º–∏–Ω\n` +
          `üöÄ –û–±—Ä–∞–±–æ—Ç–∫–∞: –í –ø–∞–º—è—Ç–∏ –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–∏—Å–∫–∞`
      );
    });

    this.bot.command("stats", async (ctx) => {
      const uptime = Math.floor(process.uptime());
      const hours = Math.floor(uptime / 3600);
      const minutes = Math.floor((uptime % 3600) / 60);
      const queueStats = getQueueStats();
      const memoryStats = getMemoryStats();

      ctx.reply(
        `üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ Memory Edition:\n\n` +
          `‚è± –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: ${hours}—á ${minutes}–º\n` +
          `üíæ –ü–∞–º—è—Ç—å –ø—Ä–æ—Ü–µ—Å—Å–∞: ${this.formatMemory(
            process.memoryUsage().rss
          )}\n` +
          `üîÑ –°—Ç–∞—Ç—É—Å: –ê–∫—Ç–∏–≤–µ–Ω (Memory Mode)\n\n` +
          `üìä –û—á–µ—Ä–µ–¥—å:\n` +
          `‚Ä¢ –û–∂–∏–¥–∞–µ—Ç: ${queueStats.queued}\n` +
          `‚Ä¢ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è: ${queueStats.processing}\n` +
          `‚Ä¢ –ó–∞–≤–µ—Ä—à–µ–Ω–æ: ${queueStats.completed}\n` +
          `‚Ä¢ –û—à–∏–±–∫–∏: ${queueStats.failed}\n\n` +
          `üíæ –ü–∞–º—è—Ç—å –æ—á–µ—Ä–µ–¥–∏: ${memoryStats.currentFormatted}\n` +
          `üìà –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: ${queueStats.throughputPerMinute} –≤–∏–¥–µ–æ/–º–∏–Ω\n` +
          `üèÜ –ü–∏–∫ –ø–∞–º—è—Ç–∏: ${memoryStats.peakFormatted}`
      );
    });
  }

  /**
   * Format memory helper
   * @param {number} bytes
   * @returns {string}
   */
  formatMemory(bytes) {
    if (bytes === 0) return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Start the bot
   */
  async launch() {
    await this.bot.launch();
    console.log("ü§ñ Telegram bot started");
  }

  /**
   * Stop the bot
   */
  stop(signal = "SIGTERM") {
    this.bot.stop(signal);
  }
}

module.exports = TelegramService;
