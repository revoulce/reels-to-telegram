const { Telegraf } = require('telegraf');
const config = require('../config');

/**
 * Video Service - handles all video processing and Telegram operations
 */
class VideoService {
    constructor(videoQueue) {
        this.videoQueue = videoQueue;
        this.bot = new Telegraf(config.BOT_TOKEN);
        this.setupCommands();
    }

    /**
     * Add video to processing queue
     */
    async downloadVideo(req, res) {
        const { videoUrl, pageUrl, timestamp } = req.body;

        console.log('\nüöÄ New video request for memory processing:', {
            pageUrl,
            hasVideoUrl: !!videoUrl,
            timestamp,
            ip: req.ip
        });

        try {
            const jobId = this.videoQueue.addJob(
                { videoUrl, pageUrl, timestamp },
                {
                    ip: req.ip,
                    userAgent: req.get('User-Agent'),
                    requestTime: new Date()
                }
            );

            const queueStats = this.videoQueue.getQueueStats();

            res.json({
                success: true,
                jobId,
                message: 'Video added to in-memory processing queue',
                queuePosition: queueStats.queued,
                estimatedWaitTime: Math.ceil(queueStats.queued / config.MAX_CONCURRENT_DOWNLOADS) * 30,
                processing: {
                    mode: 'memory',
                    zeroDiskUsage: true,
                    currentMemoryUsage: queueStats.memoryUsageFormatted,
                    memoryUtilization: queueStats.memoryUtilization
                }
            });

        } catch (error) {
            console.error('‚ùå Error adding to memory queue:', error.message);

            const statusCode = error.message.includes('Queue is full') ? 503 :
                error.message.includes('Memory') ? 507 :
                    error.message.includes('Invalid') ? 400 : 500;

            res.status(statusCode).json({
                success: false,
                error: error.message,
                ...(statusCode === 507 && {
                    memoryInfo: {
                        current: this.videoQueue.memoryManager.formatMemory(this.videoQueue.memoryManager.currentUsage),
                        max: this.videoQueue.memoryManager.formatMemory(config.MAX_TOTAL_MEMORY),
                        utilization: Math.round((this.videoQueue.memoryManager.currentUsage / config.MAX_TOTAL_MEMORY) * 100)
                    }
                })
            });
        }
    }

    /**
     * Get job status
     */
    async getJobStatus(req, res) {
        const { jobId } = req.params;
        const jobStatus = this.videoQueue.getJobStatus(jobId);

        if (!jobStatus) {
            return res.status(404).json({
                success: false,
                error: 'Job not found'
            });
        }

        const response = {
            jobId,
            status: jobStatus.status,
            progress: jobStatus.progress || 0,
            progressMessage: jobStatus.progressMessage,
            addedAt: jobStatus.addedAt,
            startedAt: jobStatus.startedAt,
            completedAt: jobStatus.completedAt,
            failedAt: jobStatus.failedAt,
            processing: {
                mode: 'memory',
                estimatedSize: jobStatus.estimatedSize
            }
        };

        if (jobStatus.status === 'completed') {
            response.result = jobStatus.result;
        }

        if (jobStatus.status === 'failed') {
            response.error = jobStatus.error;
        }

        res.json(response);
    }

    /**
     * Cancel job
     */
    async cancelJob(req, res) {
        const { jobId } = req.params;
        const cancelled = this.videoQueue.cancelJob(jobId);

        res.json({
            success: cancelled,
            message: cancelled ?
                'Job cancelled successfully' :
                'Job cannot be cancelled (not in queue or already processing)'
        });
    }

    /**
     * Send video to Telegram channel from memory buffer
     */
    async sendVideo(videoBuffer, metadata, pageUrl, jobId) {
        const caption = this.createCaption(metadata, pageUrl);

        try {
            const message = await this.bot.telegram.sendVideo(
                config.CHANNEL_ID,
                {
                    source: videoBuffer,
                    filename: `reel_${jobId.substring(0, 8)}.mp4`
                },
                {
                    caption,
                    parse_mode: 'HTML',
                    disable_notification: false
                }
            );

            console.log(`üì§ Video sent to Telegram: ${metadata.title || 'Untitled'}`);
            return message;

        } catch (error) {
            console.error(`‚ùå Telegram send failed:`, error.message);
            throw new Error(`Failed to send to Telegram: ${error.message}`);
        }
    }

    /**
     * Create caption for Telegram message
     */
    createCaption(metadata, pageUrl) {
        let caption = '';

        if (metadata.title) {
            caption += `üé¨ ${metadata.title}\n\n`;
        }

        if (metadata.author) {
            caption += `üë§ ${metadata.author}\n`;
        }

        if (metadata.view_count > 0) {
            caption += `üëÅ ${this.formatNumber(metadata.view_count)} –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤\n`;
        }

        if (metadata.like_count > 0) {
            caption += `‚ù§Ô∏è ${this.formatNumber(metadata.like_count)} –ª–∞–π–∫–æ–≤\n`;
        }

        if (metadata.duration > 0) {
            const minutes = Math.floor(metadata.duration / 60);
            const seconds = metadata.duration % 60;
            caption += `‚è± ${minutes}:${seconds.toString().padStart(2, '0')}\n`;
        }

        caption += `\nüîó ${pageUrl}`;

        return caption.substring(0, 1024);
    }

    /**
     * Format number with K/M suffixes
     */
    formatNumber(num) {
        if (!num || num === 0) return '';
        if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
        if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
        return num.toLocaleString();
    }

    /**
     * Setup bot commands
     */
    setupCommands() {
        this.bot.command('start', (ctx) => {
            ctx.reply(
                'üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –≤–∏–¥–µ–æ –∏–∑ Instagram Reels.\n\n' +
                'üîß –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –±—Ä–∞—É–∑–µ—Ä–Ω–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∏ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –µ–≥–æ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤–∏–¥–µ–æ –≤ –∫–∞–Ω–∞–ª.\n\n' +
                '‚ö° Memory Edition v3.0 –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:\n' +
                '‚Ä¢ üíæ –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∏–¥–µ–æ –≤ –ø–∞–º—è—Ç–∏ (zero disk usage)\n' +
                '‚Ä¢ üöÄ –û—á–µ—Ä–µ–¥—å –¥–æ 3 –≤–∏–¥–µ–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ\n' +
                '‚Ä¢ üìä –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏\n' +
                '‚Ä¢ üßπ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏\n\n' +
                'üìä –ö–æ–º–∞–Ω–¥—ã:\n' +
                '/memory - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏\n' +
                '/queue - —Å—Ç–∞—Ç—É—Å –æ—á–µ—Ä–µ–¥–∏\n' +
                '/stats - –æ–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n' +
                '/info - –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ'
            );
        });
    }

    /**
     * Set up command handlers with access to queue stats
     */
    setupStatsCommands(getQueueStats, getMemoryStats) {
        this.bot.command('memory', async (ctx) => {
            const memoryStats = getMemoryStats();
            const processMemory = process.memoryUsage();

            ctx.reply(
                `üíæ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏:\n\n` +
                `üîÑ –û—á–µ—Ä–µ–¥—å: ${memoryStats.currentFormatted} / ${memoryStats.maxFormatted} (${memoryStats.utilization}%)\n` +
                `üìà –ü–∏–∫: ${memoryStats.peakFormatted}\n` +
                `üñ• –ü—Ä–æ—Ü–µ—Å—Å: ${this.formatMemory(processMemory.rss)}\n` +
                `üìä Heap: ${this.formatMemory(processMemory.heapUsed)} / ${this.formatMemory(processMemory.heapTotal)}\n\n` +
                `üìπ –ê–∫—Ç–∏–≤–Ω—ã—Ö –≤—ã–¥–µ–ª–µ–Ω–∏–π: ${memoryStats.activeAllocations}\n` +
                `‚ö° –†–µ–∂–∏–º: Zero disk usage\n` +
                `üìà –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –≤—Å–µ–≥–æ: ${getQueueStats().totalProcessed}`
            );
        });

        this.bot.command('queue', async (ctx) => {
            const stats = getQueueStats();
            const memoryStats = getMemoryStats();

            ctx.reply(
                `üìä –°—Ç–∞—Ç—É—Å –æ—á–µ—Ä–µ–¥–∏ (Memory Mode):\n\n` +
                `‚è≥ –í –æ—á–µ—Ä–µ–¥–∏: ${stats.queued}\n` +
                `üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è: ${stats.processing}\n` +
                `‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ: ${stats.completed}\n` +
                `‚ùå –û—à–∏–±–∫–∏: ${stats.failed}\n` +
                `üë∑ –ê–∫—Ç–∏–≤–Ω—ã—Ö –≤–æ—Ä–∫–µ—Ä–æ–≤: ${stats.processing}/${config.MAX_CONCURRENT_DOWNLOADS}\n\n` +
                `üíæ –ü–∞–º—è—Ç—å: ${memoryStats.currentFormatted} / ${memoryStats.maxFormatted} (${memoryStats.utilization}%)\n` +
                `üìà –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: ${stats.throughputPerMinute} –≤–∏–¥–µ–æ/–º–∏–Ω\n` +
                `üöÄ –û–±—Ä–∞–±–æ—Ç–∫–∞: –í –ø–∞–º—è—Ç–∏ –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–∏—Å–∫–∞`
            );
        });

        this.bot.command('stats', async (ctx) => {
            const uptime = Math.floor(process.uptime());
            const hours = Math.floor(uptime / 3600);
            const minutes = Math.floor((uptime % 3600) / 60);
            const queueStats = getQueueStats();
            const memoryStats = getMemoryStats();

            ctx.reply(
                `üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ Memory Edition:\n\n` +
                `‚è± –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: ${hours}—á ${minutes}–º\n` +
                `üíæ –ü–∞–º—è—Ç—å –ø—Ä–æ—Ü–µ—Å—Å–∞: ${this.formatMemory(process.memoryUsage().rss)}\n` +
                `üîÑ –°—Ç–∞—Ç—É—Å: –ê–∫—Ç–∏–≤–µ–Ω (Memory Mode)\n\n` +
                `üìä –û—á–µ—Ä–µ–¥—å:\n` +
                `‚Ä¢ –û–∂–∏–¥–∞–µ—Ç: ${queueStats.queued}\n` +
                `‚Ä¢ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è: ${queueStats.processing}\n` +
                `‚Ä¢ –ó–∞–≤–µ—Ä—à–µ–Ω–æ: ${queueStats.completed}\n` +
                `‚Ä¢ –û—à–∏–±–∫–∏: ${queueStats.failed}\n\n` +
                `üíæ –ü–∞–º—è—Ç—å –æ—á–µ—Ä–µ–¥–∏: ${memoryStats.currentFormatted}\n` +
                `üìà –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: ${queueStats.throughputPerMinute} –≤–∏–¥–µ–æ/–º–∏–Ω\n` +
                `üèÜ –ü–∏–∫ –ø–∞–º—è—Ç–∏: ${memoryStats.peakFormatted}`
            );
        });
    }

    /**
     * Format memory helper
     */
    formatMemory(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * Start the bot
     */
    async launch() {
        await this.bot.launch();
        console.log('ü§ñ Telegram bot started');
    }

    /**
     * Stop the service
     * @param {string} signal - Signal to stop with
     */
    stop(signal = 'SIGTERM') {
        if (this.bot) {
            this.bot.stop(signal);
        }
    }
}

module.exports = VideoService;
